#ifndef TEXT_DRIVER_H
#define TEXT_DRIVER_H

// VGA memory and screen constants
#define VGA_MEMORY 0xA0000
#define SCREEN_WIDTH 320
#define SCREEN_HEIGHT 200

// Color definitions
#define COLOR_BLACK 0x00
#define COLOR_WHITE 0x0F
#define COLOR_GREEN 0x02
#define COLOR_BRIGHT_GREEN 0x0A
#define COLOR_GRAY 0x08

// Font data - simple 8x8 bitmap font
static unsigned char font_8x8[256][8] = {
    // Space (0x20)
    [0x20] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    // Letters A-Z
    [0x41] = {0x18, 0x3C, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x00}, // A
    [0x42] = {0x7C, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x7C, 0x00}, // B
    [0x43] = {0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C, 0x00}, // C
    [0x44] = {0x78, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0x78, 0x00}, // D
    [0x45] = {0x7E, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x7E, 0x00}, // E
    [0x46] = {0x7E, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x60, 0x00}, // F
    [0x47] = {0x3C, 0x66, 0x60, 0x6E, 0x66, 0x66, 0x3C, 0x00}, // G
    [0x48] = {0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00}, // H
    [0x49] = {0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00}, // I
    [0x4A] = {0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x6C, 0x38, 0x00}, // J
    [0x4B] = {0x66, 0x6C, 0x78, 0x70, 0x78, 0x6C, 0x66, 0x00}, // K
    [0x4C] = {0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00}, // L
    [0x4D] = {0x63, 0x77, 0x7F, 0x6B, 0x63, 0x63, 0x63, 0x00}, // M
    [0x4E] = {0x66, 0x76, 0x7E, 0x7E, 0x6E, 0x66, 0x66, 0x00}, // N
    [0x4F] = {0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00}, // O
    [0x50] = {0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x00}, // P
    [0x51] = {0x3C, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x0E, 0x00}, // Q
    [0x52] = {0x7C, 0x66, 0x66, 0x7C, 0x78, 0x6C, 0x66, 0x00}, // R
    [0x53] = {0x3C, 0x66, 0x60, 0x3C, 0x06, 0x66, 0x3C, 0x00}, // S
    [0x54] = {0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00}, // T
    [0x55] = {0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00}, // U
    [0x56] = {0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00}, // V
    [0x57] = {0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00}, // W
    [0x58] = {0x66, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x66, 0x00}, // X
    [0x59] = {0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x00}, // Y
    [0x5A] = {0x7E, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x7E, 0x00}, // Z
    // Numbers 0-9
    [0x30] = {0x3C, 0x66, 0x6E, 0x76, 0x66, 0x66, 0x3C, 0x00}, // 0
    [0x31] = {0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00}, // 1
    [0x32] = {0x3C, 0x66, 0x06, 0x0C, 0x18, 0x30, 0x7E, 0x00}, // 2
    [0x33] = {0x3C, 0x66, 0x06, 0x1C, 0x06, 0x66, 0x3C, 0x00}, // 3
    [0x34] = {0x0C, 0x1C, 0x3C, 0x6C, 0x7E, 0x0C, 0x0C, 0x00}, // 4
    [0x35] = {0x7E, 0x60, 0x7C, 0x06, 0x06, 0x66, 0x3C, 0x00}, // 5
    [0x36] = {0x3C, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x3C, 0x00}, // 6
    [0x37] = {0x7E, 0x06, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00}, // 7
    [0x38] = {0x3C, 0x66, 0x66, 0x3C, 0x66, 0x66, 0x3C, 0x00}, // 8
    [0x39] = {0x3C, 0x66, 0x66, 0x3E, 0x06, 0x0C, 0x38, 0x00}, // 9
    // Special characters
    [0x2E] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00}, // .
    [0x21] = {0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00}, // !
};

// Function prototypes
void clear_screen(unsigned char color);
void draw_pixel(int x, int y, unsigned char color);
void draw_rectangle(int x, int y, int width, int height, unsigned char color);
void draw_char(int x, int y, char c, unsigned char color, int scale);
void draw_string(int x, int y, const char* str, unsigned char color, int scale);
void show_loading_screen(void);

// Clear the entire screen with a specific color
void clear_screen(unsigned char color) {
    unsigned char* vga = (unsigned char*)VGA_MEMORY;
    for (int i = 0; i < SCREEN_WIDTH * SCREEN_HEIGHT; i++) {
        vga[i] = color;
    }
}

// Draw a single pixel
void draw_pixel(int x, int y, unsigned char color) {
    if (x >= 0 && x < SCREEN_WIDTH && y >= 0 && y < SCREEN_HEIGHT) {
        unsigned char* vga = (unsigned char*)VGA_MEMORY;
        vga[y * SCREEN_WIDTH + x] = color;
    }
}

// Draw a filled rectangle
void draw_rectangle(int x, int y, int width, int height, unsigned char color) {
    for (int row = 0; row < height; row++) {
        for (int col = 0; col < width; col++) {
            draw_pixel(x + col, y + row, color);
        }
    }
}

// Draw a single character with scaling
void draw_char(int x, int y, char c, unsigned char color, int scale) {
    unsigned char* font_char = font_8x8[(unsigned char)c];
    
    for (int row = 0; row < 8; row++) {
        for (int col = 0; col < 8; col++) {
            if (font_char[row] & (0x80 >> col)) {
                // Draw scaled pixel block
                for (int sy = 0; sy < scale; sy++) {
                    for (int sx = 0; sx < scale; sx++) {
                        draw_pixel(x + col * scale + sx, y + row * scale + sy, color);
                    }
                }
            }
        }
    }
}

// Draw a string with scaling
void draw_string(int x, int y, const char* str, unsigned char color, int scale) {
    int current_x = x;
    while (*str) {
        draw_char(current_x, y, *str, color, scale);
        current_x += 8 * scale; // Move to next character position
        str++;
    }
}

// Main loading screen function
void show_loading_screen(void) {
    // Clear screen to black immediately
    clear_screen(COLOR_BLACK);
    
    // Draw "Loading..." text (large and clear)
    draw_string(104, 70, "Loading...", COLOR_WHITE, 2);
    
    // Draw loading bar background
    draw_rectangle(60, 100, 200, 20, COLOR_GRAY);
    
    // Animate progress bar (5 seconds total)
    for (int progress = 0; progress <= 200; progress += 2) {
        // Draw progress bar
        draw_rectangle(60, 102, progress, 16, COLOR_GREEN);
        
        // Delay for timing (approximately 25ms per step)
        for (volatile int delay = 0; delay < 100000; delay++);
    }
    
    // Show completion message
    draw_string(72, 130, "Loading Complete!", COLOR_BRIGHT_GREEN, 2);
    
    // Final delay
    for (volatile int delay = 0; delay < 2000000; delay++);
}

#endif // TEXT_DRIVER_H
